# Mouse-click-game
CS171 project

Click

I.	Introduction to my project

I chose to create a Probability and Shapes game, called ‘Click’, for my project. My reasoning for this choice is that I felt I would have a lot fun in making it. I thought it would easy for me to complete and I would be able to express my creativity.

II.	What does my project do?

My project is a game designed to test the focus of the player, as well as the speed of their reaction. It incorporates user interaction, geometric shapes and shows the probability of the player completing the game. The aim of the game is to click on every shape (circle, square and triangle) before they pass the screen. There are three phases and the travel speed of each shape increases as the player progresses through each phase. Lastly, the player is given three lives to start with and for each time they fail to click on a shape before it passes the screen, they lose a life. When all lives a lost, the player loses the game.

III.	How does my project work?

At the very start of my code, the program imports several audio files. These audio files are used for when the player loses a life or clicks on a shape. They are also used for background music, victory music and for when the player loses the game.
Before the program is set up, many variables are declared. The data of the background image is stored in the program. The number lives the player is given is set to 3 and the phase they start at is set to 1. The x-coordinates of all three shapes are established outside of the player’s view. The program also randomly selects three colours for these shapes to be filled in. The travel speed of each shape in each phase is randomly selected as well, apart from Phase 3. Finally, the variable ‘exitGame’ is set to 0, which the program uses to decide whether the game is over or not. Additionally, the Boolean expressions that follow are set to true and are used to decide which audio file the program should play.
Next, the program sets the game window size to 1000x1000 pixels. It then loads the background music and plays it from start to finish. It also loads the background image, which is 1000x1000 pixels large. The speeds of each shape in each phase are displayed in the console.
After the program is set up, it proceeds to animate. The background image is refreshed every frame. The x-coordinate of the square is now equal to itself less the travel speed of it in Phase 1. This allows the square to travel from right to left. The colour of the square is filled in and its size is declared. Whenever the square reaches the left side of the screen, out of the player’s view, the player loses a life, the square is relocated back to its starting position, and the audio file for when the player loses a life is loaded and played. The same steps are repeated for the circle and triangle. My program uses three individual points to draw triangles. This means in order to animate the triangle, the speed the triangle should travel at need to be taken away from the x-coordinates of all three points.
When the player has clicked on a shape 33 times, they advance to Phase 2; and when they click on a shape 67 times, they advance to the final phase. Each time this occurs, the travel speeds of the shapes increase.
At the very top of the screen, the number of lives the player has left and the phase they are currently in are displayed. The current probability of the player completing the game from their current position is also presented. The aim of the game is shown at the very bottom of the screen.
When the user has no lives left, the background music ends and the sound file for when the game is lost is loaded and played. The text “FAILURE” is displayed on screen and all shapes are repositioned so the user cannot click on any more shapes. The user is also given the option to restart the game by pressing ‘R’ on the keyboard or quit by pressing ‘E’. The same process is followed for when the user clicks on a shape 100 times, but the text “SUCCESS” is displayed and the victory music is loaded and played instead.
Finally, each time any mouse button is pressed inside of any shape, the total number of shapes the player has clicked on increases by 1, the shape is repositioned to its starting location, and the audio file for when a shape is clicked on is loaded and played.
My program decides whether or not the mouse is inside the square by checking if the x-position of the mouse is less than its size on the x-axis but greater than its x-coordinate; while the y-position of the mouse is less than 550 but greater than 400. To determine whether or not the mouse is inside the circle, my program calculates the distances between the mouse’s x-position and circles’ x-coordinate, and the mouse’s y-position and circle’s y-coordinate. It then checks to see if they are less than the circle’s radius, and if so, my program believes the mouse is inside the circle. Due to the way my program draws triangles, it uses a certain method to find out when the mouse hovering over the triangle. It finds the area of the triangle and area of three smaller triangles that would make up the size of the original triangle. If the sum of the area of the smaller triangles is equal to the area of the original, my program then knows that the mouse is hovering over the triangle. However, these calculations may not always be correct so it allows for a margin of error, the number unit, 0.05.
As mentioned before, pressing on ‘R’ reboots the game. When this happens, all shapes are repositioned and start at their Phase 1 speed. The user is given three lives again and the background music starts from the beginning. The program also stops the victory or game lost music from playing.

IV.	How I developed the program and problems I had to solve

A variety of sources helped me develop the program. These sources include: YouTube, the Processing website and its forums, and the CS171 lab work.
I ran into many issues while developing my game. Initially, I was going to have many different shapes fly across the screen, with their y-coordinates changing each time, and the player would only have to click on squares. However, I realised it would be difficult to code different travel patterns for shapes without them overlapping each other. I also wanted to adjust the size of each shape when they repositioned. Again, this would be too difficult to code as the shapes would overlap each other.
Another issue, I had was with the mouse click detection of the triangle. I discovered that there may be some errors when calculating the area of an animated triangle. I read in a forum post that Processing rounds the area of the smaller triangles to the nearest float number. Fortunately, if I allow for a margin of error, the issue should be fixed.
The biggest problem I had in making this project was getting the victory and game lost audio files to function. I went to the Computer Science Centre, where a demonstrator taught me to use Boolean expressions to help my game transition from its background music to its game finished music.
